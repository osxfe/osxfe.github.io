<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="-React -ES6," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="一、React简介1、Virtual DOMReact为此引入了虚拟DOM的机制，在浏览器端用Javascript实现了一套DOM API。基于React进行开发时所有的DOM构造都是通过虚拟DOM进行，每当数据变化时，React都会重新构建整个DOM树，然后React将当前整个DOM树和上一次的DOM树进行对比，得到DOM结构的区别，然后仅仅将需要变化的部分进行实际的浏览器DOM更新。 2、组件">
<meta name="keywords" content="-React -ES6">
<meta property="og:type" content="article">
<meta property="og:title" content="React原理浅谈">
<meta property="og:url" content="http://yoursite.com/2017/07/17/React/index.html">
<meta property="og:site_name" content="OSXFE">
<meta property="og:description" content="一、React简介1、Virtual DOMReact为此引入了虚拟DOM的机制，在浏览器端用Javascript实现了一套DOM API。基于React进行开发时所有的DOM构造都是通过虚拟DOM进行，每当数据变化时，React都会重新构建整个DOM树，然后React将当前整个DOM树和上一次的DOM树进行对比，得到DOM结构的区别，然后仅仅将需要变化的部分进行实际的浏览器DOM更新。 2、组件">
<meta property="og:image" content="http://yoursite.com/images/react-component.png">
<meta property="og:image" content="http://yoursite.com/images/react-first-render.png">
<meta property="og:updated_time" content="2017-12-07T02:27:57.804Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="React原理浅谈">
<meta name="twitter:description" content="一、React简介1、Virtual DOMReact为此引入了虚拟DOM的机制，在浏览器端用Javascript实现了一套DOM API。基于React进行开发时所有的DOM构造都是通过虚拟DOM进行，每当数据变化时，React都会重新构建整个DOM树，然后React将当前整个DOM树和上一次的DOM树进行对比，得到DOM结构的区别，然后仅仅将需要变化的部分进行实际的浏览器DOM更新。 2、组件">
<meta name="twitter:image" content="http://yoursite.com/images/react-component.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/07/17/React/"/>





  <title>React原理浅谈 | OSXFE</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">OSXFE</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/17/React/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="osxfe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="OSXFE">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">React原理浅谈</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
            <span class="post-meta-item-text">作者: Jian Wang </span>
            <span class="post-meta-divider">|</span>
            
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-17T20:43:30+08:00">
                2017-07-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="一、React简介"><a href="#一、React简介" class="headerlink" title="一、React简介"></a>一、React简介</h2><h3 id="1、Virtual-DOM"><a href="#1、Virtual-DOM" class="headerlink" title="1、Virtual DOM"></a>1、Virtual DOM</h3><p>React为此引入了虚拟DOM的机制，在浏览器端用Javascript实现了一套DOM API。基于React进行开发时所有的DOM构造都是通过虚拟DOM进行，每当数据变化时，React都会重新构建整个DOM树，然后React将当前整个DOM树和上一次的DOM树进行对比，得到DOM结构的区别，然后仅仅将需要变化的部分进行实际的浏览器DOM更新。</p>
<h3 id="2、组件化"><a href="#2、组件化" class="headerlink" title="2、组件化"></a>2、组件化</h3><p>组件是封装起来的具有独立功能的UI部件<br><img src="/images/react-component.png"></p>
<h4 id="React组件应具有如下特征"><a href="#React组件应具有如下特征" class="headerlink" title="React组件应具有如下特征"></a>React组件应具有如下特征</h4><ul>
<li>可组合(Composeable): 一个组件易于和其它组件一起使用，或者嵌套在另一个组件内部;如果一个组件内部创建了另一个组件，那么说父组件拥有（own）它创建的子组件，通过这个特性，一个复杂的UI可以拆分成多个简单的UI组件</li>
<li>可重用(Reusable): 每个组件都是具有独立功能的，它可以被使用在多个UI场景</li>
<li>可维护(Maintainable): 每个小的组件仅仅包含自身的逻辑，更容易被理解和维护</li>
</ul>
<h2 id="二、React原理分析"><a href="#二、React原理分析" class="headerlink" title="二、React原理分析"></a>二、React原理分析</h2><h4 id="ReactJs的核心内容主要包括"><a href="#ReactJs的核心内容主要包括" class="headerlink" title="ReactJs的核心内容主要包括"></a>ReactJs的核心内容主要包括</h4><ul>
<li>虚拟dom对象(Virtual DOM)</li>
<li>虚拟dom差异化算法（diff algorithm）</li>
<li>单向数据流渲染（Data Flow）</li>
<li>组件生命周期</li>
<li>事件处理</li>
</ul>
<h3 id="1、ReactJs首次渲染"><a href="#1、ReactJs首次渲染" class="headerlink" title="1、ReactJs首次渲染"></a>1、ReactJs首次渲染</h3><p><img src="/images/react-first-render.png"></p>
<p>虚拟dom元素分为两种，一种是浏览器自带的基本元素比如 div p input form 这种，一种是自定义的元素。<br>文本节点，不算虚拟dom，但是ReacJs为了保持渲染的一致性, 在文本节点外面包了一层span标记，形成简化版的component（ReactDOMTextComponent）。</p>
<h4 id="文本节点渲染"><a href="#文本节点渲染" class="headerlink" title="文本节点渲染"></a>文本节点渲染</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//component类，用来表示文本在渲染，更新，删除时应该做些什么事情</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReactDOMTextComponent</span>(<span class="params">text</span>) </span>&#123;</div><div class="line">    <span class="comment">//存下当前的字符串</span></div><div class="line">    <span class="keyword">this</span>._currentElement = <span class="string">''</span> + text;</div><div class="line">    <span class="comment">//用来标识当前component</span></div><div class="line">    <span class="keyword">this</span>._rootNodeID = <span class="literal">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//component渲染时生成的dom结构</span></div><div class="line">ReactDOMTextComponent.prototype.mountComponent = <span class="function"><span class="keyword">function</span>(<span class="params">rootID</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>._rootNodeID = rootID;</div><div class="line">    <span class="keyword">return</span> <span class="string">'&lt;span data-reactid="'</span> + rootID + <span class="string">'"&gt;'</span> + <span class="keyword">this</span>._currentElement + <span class="string">'&lt;/span&gt;'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//component工厂  用来返回一个component实例</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">instantiateReactComponent</span>(<span class="params">node</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> node === <span class="string">'string'</span> || <span class="keyword">typeof</span> node === <span class="string">'number'</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReactDOMTextComponent(node)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">React = &#123;</div><div class="line">    <span class="attr">nextReactRootIndex</span>:<span class="number">0</span>,</div><div class="line">    <span class="attr">render</span>:<span class="function"><span class="keyword">function</span>(<span class="params">element,container</span>)</span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> componentInstance = instantiateReactComponent(element);</div><div class="line">        <span class="keyword">var</span> markup = componentInstance.mountComponent(React.nextReactRootIndex++);</div><div class="line">        $(container).html(markup);</div><div class="line">        <span class="comment">//触发完成mount的事件</span></div><div class="line">        $(<span class="built_in">document</span>).trigger(<span class="string">'mountReady'</span>);    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>React.render 作为入口负责调用渲染</li>
<li>ReactDOMTextComponent是一个component类定义，定义对于这种文本类型的节点，在渲染，更新，删除时应该做什么操作</li>
<li>instantiateReactComponent用来根据element的类型（现在只有一种string类型），返回一个component的实例。其实就是个类工厂</li>
</ul>
<h4 id="基本元素渲染"><a href="#基本元素渲染" class="headerlink" title="基本元素渲染"></a>基本元素渲染</h4><p>在React中使用React.createElement来创建一个虚拟dom元素, 例如:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="string">'hello'</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> element = React.createElement(<span class="string">'div'</span>,&#123;<span class="attr">id</span>:<span class="string">'test'</span>,<span class="attr">onclick</span>:hello&#125;,<span class="string">'click me'</span>)</div><div class="line"></div><div class="line">React.render(element,<span class="built_in">document</span>.getElementById(<span class="string">"container"</span>))</div></pre></td></tr></table></figure></p>
<p>当render的不是文本而是浏览器的基本元素时，使用另外一种component来处理它渲染时应该返回的内容，由于使用的是工厂方法instantiateReactComponent，不管来了什么类型的node，都可以负责生产出一个负责渲染的component实例。这样render完全不需要做任何修改，只需要再做一种对应的component类型ReactDOMComponent就行了。<br>虚拟dom的渲染逻辑，本质上还是个递归渲染的东西，reactElement会递归渲染自己的子节点。可以看到我们通过instantiateReactComponent屏蔽了子节点的差异，只需要使用不同的componet类，这样都能保证通过mountComponent最终拿到渲染后的内容。</p>
<h4 id="自定义元素渲染"><a href="#自定义元素渲染" class="headerlink" title="自定义元素渲染"></a>自定义元素渲染</h4><p>随着前端技术的发展浏览器的那些基本元素已经满足不了我们的需求了，ReactJs的element.type可以是简单的字符串也可以是个类，而且这个类还有自己的生命周期管理。</p>
<blockquote>
<p>生命周期共提供了10个不同的API<br>1.getDefaultProps<br>2.getInitialState<br>3.componentWillMount<br>4.render<br>5.componentDidMount<br>6.componentWillReceiveProps<br>7.shouldComponentUpdate<br>8.componentWillUpdate<br>9.componentDidUpdate<br>10.componentWillUnmount</p>
</blockquote>
<p>自定义元素,React.createElement接受的不再是字符串，而是一个class<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> HelloMessage = React.createClass(&#123;</div><div class="line">  <span class="attr">getInitialState</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;<span class="attr">type</span>: <span class="string">'say:'</span>&#125;;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">componentWillMount</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'我就要开始渲染了。。。'</span>)</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">componentDidMount</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'我已经渲染好了。。。'</span>)</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> React.createElement(<span class="string">"div"</span>, <span class="literal">null</span>,<span class="keyword">this</span>.state.type, <span class="string">"Hello "</span>, <span class="keyword">this</span>.props.name);</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">React.render(React.createElement(HelloMessage, &#123;<span class="attr">name</span>: <span class="string">"John"</span>&#125;), <span class="built_in">document</span>.getElementById(<span class="string">"container"</span>));</div></pre></td></tr></table></figure></p>
<ul>
<li>React.createClass生成一个自定义标记类，带有基本的生命周期：</li>
<li>getInitialState 获取最初的属性值this.state</li>
<li>componentWillmount 在组件准备渲染时调用</li>
<li>componentDidMount 在组件渲染完成后调用</li>
</ul>
<p>通过上面的两种类型知道，需要未自定义元素也提供一个componet类，在这个类里我们会实例化ReactClass，并且管理生命周期，还有父子组件依赖。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReactCompositeComponent</span>(<span class="params">element</span>)</span>&#123;</div><div class="line">    <span class="comment">//存放元素element对象</span></div><div class="line">    <span class="keyword">this</span>._currentElement = element;</div><div class="line">    <span class="comment">//存放唯一标识</span></div><div class="line">    <span class="keyword">this</span>._rootNodeID = <span class="literal">null</span>;</div><div class="line">    <span class="comment">//存放对应的ReactClass的实例</span></div><div class="line">    <span class="keyword">this</span>._instance = <span class="literal">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//用于返回当前自定义元素渲染时应该返回的内容</span></div><div class="line">ReactCompositeComponent.prototype.mountComponent = <span class="function"><span class="keyword">function</span>(<span class="params">rootID</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>._rootNodeID = rootID;</div><div class="line">    <span class="comment">//拿到当前元素对应的属性值</span></div><div class="line">    <span class="keyword">var</span> publicProps = <span class="keyword">this</span>._currentElement.props;</div><div class="line">    <span class="comment">//拿到对应的ReactClass</span></div><div class="line">    <span class="keyword">var</span> ReactClass = <span class="keyword">this</span>._currentElement.type;</div><div class="line">    <span class="comment">// Initialize the public class</span></div><div class="line">    <span class="keyword">var</span> inst = <span class="keyword">new</span> ReactClass(publicProps);</div><div class="line">    <span class="keyword">this</span>._instance = inst;</div><div class="line">    <span class="comment">//保留对当前comonent的引用，下面更新会用到</span></div><div class="line">    inst._reactInternalInstance = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (inst.componentWillMount) &#123;</div><div class="line">        inst.componentWillMount();</div><div class="line">        <span class="comment">//这里在原始的reactjs其实还有一层处理，就是  componentWillMount调用setstate，不会触发rerender而是自动提前合并，这里为了保持简单，就略去了</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//调用ReactClass的实例的render方法,返回一个element或者一个文本节点</span></div><div class="line">    <span class="keyword">var</span> renderedElement = <span class="keyword">this</span>._instance.render();</div><div class="line">    <span class="comment">//得到renderedElement对应的component类实例</span></div><div class="line">    <span class="keyword">var</span> renderedComponentInstance = instantiateReactComponent(renderedElement);</div><div class="line">    <span class="keyword">this</span>._renderedComponent = renderedComponentInstance; <span class="comment">//存起来留作后用</span></div><div class="line"></div><div class="line">    <span class="comment">//拿到渲染之后的字符串内容，将当前的_rootNodeID传给render出的节点</span></div><div class="line">    <span class="keyword">var</span> renderedMarkup = renderedComponentInstance.mountComponent(<span class="keyword">this</span>._rootNodeID);</div><div class="line"></div><div class="line">    <span class="comment">//之前我们在React.render方法最后触发了mountReady事件，所以这里可以监听，在渲染完成后会触发。</span></div><div class="line">    $(<span class="built_in">document</span>).on(<span class="string">'mountReady'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">//调用inst.componentDidMount</span></div><div class="line">        inst.componentDidMount &amp;&amp; inst.componentDidMount();</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> renderedMarkup;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2、更新机制"><a href="#2、更新机制" class="headerlink" title="2、更新机制"></a>2、更新机制</h3><p>一般在reactjs中我们需要更新时都是调用的setState<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//setState</span></div><div class="line">ReactClass.prototype.setState = <span class="function"><span class="keyword">function</span>(<span class="params">newState</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//还记得我们在ReactCompositeComponent里面mount的时候 做了赋值</span></div><div class="line">    <span class="comment">//所以这里可以拿到 对应的ReactCompositeComponent的实例_reactInternalInstance</span></div><div class="line">    <span class="keyword">this</span>._reactInternalInstance.receiveComponent(<span class="literal">null</span>, newState);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>setState主要调用了对应的component的receiveComponent来实现更新。所有的挂载，更新都应该交给对应的component来管理</li>
<li>就像所有的component都实现了mountComponent来处理第一次渲染，所有的componet类都应该实现receiveComponent用来处理自己的更新</li>
</ul>
<h4 id="自定义元素的receiveComponent"><a href="#自定义元素的receiveComponent" class="headerlink" title="自定义元素的receiveComponent"></a>自定义元素的receiveComponent</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//更新</span></div><div class="line">ReactCompositeComponent.prototype.receiveComponent = <span class="function"><span class="keyword">function</span>(<span class="params">nextElement, newState</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//如果接受了新的，就使用最新的element</span></div><div class="line">    <span class="keyword">this</span>._currentElement = nextElement || <span class="keyword">this</span>._currentElement</div><div class="line"></div><div class="line">    <span class="keyword">var</span> inst = <span class="keyword">this</span>._instance;</div><div class="line">    <span class="comment">//合并state</span></div><div class="line">    <span class="keyword">var</span> nextState = $.extend(inst.state, newState);</div><div class="line">    <span class="keyword">var</span> nextProps = <span class="keyword">this</span>._currentElement.props;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">//改写state</span></div><div class="line">    inst.state = nextState;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">//如果inst有shouldComponentUpdate并且返回false。说明组件本身判断不要更新，就直接返回。</span></div><div class="line">    <span class="keyword">if</span> (inst.shouldComponentUpdate &amp;&amp; (inst.shouldComponentUpdate(nextProps, nextState) === <span class="literal">false</span>)) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="comment">//生命周期管理，如果有componentWillUpdate，就调用，表示开始要更新了。</span></div><div class="line">    <span class="keyword">if</span> (inst.componentWillUpdate) inst.componentWillUpdate(nextProps, nextState);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">var</span> prevComponentInstance = <span class="keyword">this</span>._renderedComponent;</div><div class="line">    <span class="keyword">var</span> prevRenderedElement = prevComponentInstance._currentElement;</div><div class="line">    <span class="comment">//重新执行render拿到对应的新element;</span></div><div class="line">    <span class="keyword">var</span> nextRenderedElement = <span class="keyword">this</span>._instance.render();</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">//判断是需要更新还是直接就重新渲染</span></div><div class="line">    <span class="comment">//注意这里的_shouldUpdateReactComponent跟上面的不同哦 这个是全局的方法</span></div><div class="line">    <span class="keyword">if</span> (_shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) &#123;</div><div class="line">        <span class="comment">//如果需要更新，就继续调用子节点的receiveComponent的方法，传入新的element更新子节点。</span></div><div class="line">        prevComponentInstance.receiveComponent(nextRenderedElement);</div><div class="line">        <span class="comment">//调用componentDidUpdate表示更新完成了</span></div><div class="line">        inst.componentDidUpdate &amp;&amp; inst.componentDidUpdate();</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//如果发现完全是不同的两种element，那就干脆重新渲染了</span></div><div class="line">        <span class="keyword">var</span> thisID = <span class="keyword">this</span>._rootNodeID;</div><div class="line">        <span class="comment">//重新new一个对应的component，</span></div><div class="line">        <span class="keyword">this</span>._renderedComponent = <span class="keyword">this</span>._instantiateReactComponent(nextRenderedElement);</div><div class="line">        <span class="comment">//重新生成对应的元素内容</span></div><div class="line">        <span class="keyword">var</span> nextMarkup = _renderedComponent.mountComponent(thisID);</div><div class="line">        <span class="comment">//替换整个节点</span></div><div class="line">        $(<span class="string">'[data-reactid="'</span> + <span class="keyword">this</span>._rootNodeID + <span class="string">'"]'</span>).replaceWith(nextMarkup);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//用来判定两个element需不需要更新</span></div><div class="line"><span class="comment">//这里的key是我们createElement的时候可以选择性的传入的。用来标识这个element，当发现key不同时，我们就可以直接重新渲染，不需要去更新了。</span></div><div class="line"><span class="keyword">var</span> _shouldUpdateReactComponent ＝ <span class="function"><span class="keyword">function</span>(<span class="params">prevElement, nextElement</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (prevElement != <span class="literal">null</span> &amp;&amp; nextElement != <span class="literal">null</span>) &#123;</div><div class="line">    <span class="keyword">var</span> prevType = <span class="keyword">typeof</span> prevElement;</div><div class="line">    <span class="keyword">var</span> nextType = <span class="keyword">typeof</span> nextElement;</div><div class="line">    <span class="keyword">if</span> (prevType === <span class="string">'string'</span> || prevType === <span class="string">'number'</span>) &#123;</div><div class="line">      <span class="keyword">return</span> nextType === <span class="string">'string'</span> || nextType === <span class="string">'number'</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> nextType === <span class="string">'object'</span> &amp;&amp; prevElement.type === nextElement.type &amp;&amp; prevElement.key === nextElement.key;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>inst.shouldComponentUpdate是实例方法，当我们不希望某次setState后更新，我们就可以重写这个方法，返回false就好了。</li>
<li>_shouldUpdateReactComponent是一个全局方法，这个是一种reactjs的优化机制。用来决定是直接全部替换，还是使用很细微的改动。当两次render出来的子节点key不同，直接全部重新渲染一遍，替换就好了。否则，我们就得来个递归的更新，保证最小化的更新机制，这样可以不会有太大的闪烁。</li>
</ul>
<p>首先合并改动，生成最新的state,props然后拿以前的render返回的element跟现在最新调用render生成的element进行对比（_shouldUpdateReactComponent），看看需不需要更新，如果要更新就继续调用对应的component类对应的receiveComponent就好啦，其实就是直接当甩手掌柜，事情直接丢给手下去办了。当然还有种情况是，两次生成的element差别太大，就不是一个类型的，那就直接重新生成一份新的代码重新渲染一次。</p>
<ul>
<li>自定义元素的更新，主要是更新render出的节点，做甩手掌柜交给render出的节点的对应component去管理更新。</li>
<li>text节点的更新很简单，直接更新文案。</li>
<li>浏览器基本元素的更新，分为两块：1.先是更新属性，对比出前后属性的不同，局部更新。并且处理特殊属性，比如事件绑定。2.更新子节点，子节点更新主要是找出差异对象，找差异对象的时候使用_shouldUpdateReactComponent来判断，如果是可以直接更新的就会递归调用子节点的更新，这样也会递归查找差异对象。</li>
</ul>
<h4 id="更新属性"><a href="#更新属性" class="headerlink" title="更新属性"></a>更新属性</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">ReactDOMComponent.prototype._updateDOMProperties = <span class="function"><span class="keyword">function</span>(<span class="params">lastProps, nextProps</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> propKey;</div><div class="line">    <span class="comment">//遍历，当一个老的属性不在新的属性集合里时，需要删除掉。</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> (propKey <span class="keyword">in</span> lastProps) &#123;</div><div class="line">        <span class="comment">//新的属性里有，或者propKey是在原型上的直接跳过。这样剩下的都是不在新属性集合里的。需要删除</span></div><div class="line">        <span class="keyword">if</span> (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey)) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//对于那种特殊的，比如这里的事件监听的属性我们需要去掉监听</span></div><div class="line">        <span class="keyword">if</span> (<span class="regexp">/^on[A-Za-z]/</span>.test(propKey)) &#123;</div><div class="line">            <span class="keyword">var</span> eventType = propKey.replace(<span class="string">'on'</span>, <span class="string">''</span>);</div><div class="line">            <span class="comment">//针对当前的节点取消事件代理</span></div><div class="line">            $(<span class="built_in">document</span>).undelegate(<span class="string">'[data-reactid="'</span> + <span class="keyword">this</span>._rootNodeID + <span class="string">'"]'</span>, eventType, lastProps[propKey]);</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//从dom上删除不需要的属性</span></div><div class="line">        $(<span class="string">'[data-reactid="'</span> + <span class="keyword">this</span>._rootNodeID + <span class="string">'"]'</span>).removeAttr(propKey)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//对于新的属性，需要写到dom节点上</span></div><div class="line">    <span class="keyword">for</span> (propKey <span class="keyword">in</span> nextProps) &#123;</div><div class="line">        <span class="comment">//对于事件监听的属性我们需要特殊处理</span></div><div class="line">        <span class="keyword">if</span> (<span class="regexp">/^on[A-Za-z]/</span>.test(propKey)) &#123;</div><div class="line">            <span class="keyword">var</span> eventType = propKey.replace(<span class="string">'on'</span>, <span class="string">''</span>);</div><div class="line">            <span class="comment">//以前如果已经有，说明有了监听，需要先去掉</span></div><div class="line">            lastProps[propKey] &amp;&amp; $(<span class="built_in">document</span>).undelegate(<span class="string">'[data-reactid="'</span> + <span class="keyword">this</span>._rootNodeID + <span class="string">'"]'</span>, eventType, lastProps[propKey]);</div><div class="line">            <span class="comment">//针对当前的节点添加事件代理,以_rootNodeID为命名空间</span></div><div class="line">            $(<span class="built_in">document</span>).delegate(<span class="string">'[data-reactid="'</span> + <span class="keyword">this</span>._rootNodeID + <span class="string">'"]'</span>, eventType + <span class="string">'.'</span> + <span class="keyword">this</span>._rootNodeID, nextProps[propKey]);</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (propKey == <span class="string">'children'</span>) <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">        <span class="comment">//添加新的属性，或者是更新老的同名属性</span></div><div class="line">        $(<span class="string">'[data-reactid="'</span> + <span class="keyword">this</span>._rootNodeID + <span class="string">'"]'</span>).prop(propKey, nextProps[propKey])</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="string">``</span><span class="string">`                </span></div><div class="line">#### 更新子节点</div><div class="line">更新子节点包含两个部分，一个是递归的分析差异，把差异添加到队列中。然后在合适的时机调用_patch把差异应用到dom上</div><div class="line">`<span class="string">``</span>js</div><div class="line">ReactDOMComponent.prototype.receiveComponent = <span class="function"><span class="keyword">function</span>(<span class="params">nextElement</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> lastProps = <span class="keyword">this</span>._currentElement.props;</div><div class="line">    <span class="keyword">var</span> nextProps = nextElement.props;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>._currentElement = nextElement;</div><div class="line">    <span class="comment">//需要单独的更新属性</span></div><div class="line">    <span class="keyword">this</span>._updateDOMProperties(lastProps,nextProps);</div><div class="line">    <span class="comment">//再更新子节点</span></div><div class="line">    <span class="keyword">this</span>._updateDOMChildren(nextProps.children);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//全局的更新深度标识</span></div><div class="line"><span class="keyword">var</span> updateDepth = <span class="number">0</span>;</div><div class="line"><span class="comment">//全局的更新队列，所有的差异都存在这里</span></div><div class="line"><span class="keyword">var</span> diffQueue = [];</div><div class="line"></div><div class="line">ReactDOMComponent.prototype._updateDOMChildren = <span class="function"><span class="keyword">function</span>(<span class="params">nextChildrenElements</span>)</span>&#123;</div><div class="line">    updateDepth++</div><div class="line">    <span class="comment">//_diff用来递归找出差别,组装差异对象,添加到更新队列diffQueue。</span></div><div class="line">    <span class="keyword">this</span>._diff(diffQueue,nextChildrenElements);</div><div class="line">    updateDepth--</div><div class="line">    <span class="keyword">if</span>(updateDepth == <span class="number">0</span>)&#123;</div><div class="line">        <span class="comment">//在需要的时候调用patch，执行具体的dom操作</span></div><div class="line">        <span class="keyword">this</span>._patch(diffQueue);</div><div class="line">        diffQueue = [];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>_diff用来递归找出差别,组装差异对象,添加到更新队列diffQueue。</li>
<li>_patch主要就是挨个遍历差异队列，遍历两次，第一次删除掉所有需要变动的节点，然后第二次插入新的节点还有修改的节点。这里为什么可以直接挨个的插入呢？原因就是我们在diff阶段添加差异节点到差异队列时，本身就是有序的，也就是说对于新增节点（包括move和insert的）在队列里的顺序就是最终dom的顺序，所以我们才可以挨个的直接根据index去塞入节点。</li>
</ul>
<h4 id="diff实现"><a href="#diff实现" class="headerlink" title="_diff实现"></a>_diff实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//差异更新的几种类型</span></div><div class="line"><span class="keyword">var</span> UPATE_TYPES = &#123;</div><div class="line">    <span class="attr">MOVE_EXISTING</span>: <span class="number">1</span>,</div><div class="line">    <span class="attr">REMOVE_NODE</span>: <span class="number">2</span>,</div><div class="line">    <span class="attr">INSERT_MARKUP</span>: <span class="number">3</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//普通的children是一个数组，此方法把它转换成一个map,key就是element的key,如果是text节点或者element创建时并没有传入key,就直接用在数组里的index标识</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">flattenChildren</span>(<span class="params">componentChildren</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> child;</div><div class="line">    <span class="keyword">var</span> name;</div><div class="line">    <span class="keyword">var</span> childrenMap = &#123;&#125;;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; componentChildren.length; i++) &#123;</div><div class="line">        child = componentChildren[i];</div><div class="line">        name = child &amp;&amp; child._currentelement &amp;&amp; child._currentelement.key ? child._currentelement.key : i.toString(<span class="number">36</span>);</div><div class="line">        childrenMap[name] = child;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> childrenMap;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//主要用来生成子节点elements的component集合</span></div><div class="line"><span class="comment">//这边注意，有个判断逻辑，如果发现是更新，就会继续使用以前的componentInstance,调用对应的receiveComponent。</span></div><div class="line"><span class="comment">//如果是新的节点，就会重新生成一个新的componentInstance，</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateComponentChildren</span>(<span class="params">prevChildren, nextChildrenElements</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> nextChildren = &#123;&#125;;</div><div class="line">    nextChildrenElements = nextChildrenElements || [];</div><div class="line">    $.each(nextChildrenElements, <span class="function"><span class="keyword">function</span>(<span class="params">index, element</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> name = element.key ? element.key : index;</div><div class="line">        <span class="keyword">var</span> prevChild = prevChildren &amp;&amp; prevChildren[name];</div><div class="line">        <span class="keyword">var</span> prevElement = prevChild &amp;&amp; prevChild._currentElement;</div><div class="line">        <span class="keyword">var</span> nextElement = element;</div><div class="line"></div><div class="line">        <span class="comment">//调用_shouldUpdateReactComponent判断是否是更新</span></div><div class="line">        <span class="keyword">if</span> (_shouldUpdateReactComponent(prevElement, nextElement)) &#123;</div><div class="line">            <span class="comment">//更新的话直接递归调用子节点的receiveComponent就好了</span></div><div class="line">            prevChild.receiveComponent(nextElement);</div><div class="line">            <span class="comment">//然后继续使用老的component</span></div><div class="line">            nextChildren[name] = prevChild;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//对于没有老的，那就重新新增一个，重新生成一个component</span></div><div class="line">            <span class="keyword">var</span> nextChildInstance = instantiateReactComponent(nextElement, <span class="literal">null</span>);</div><div class="line">            <span class="comment">//使用新的component</span></div><div class="line">            nextChildren[name] = nextChildInstance;</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> nextChildren;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//_diff用来递归找出差别,组装差异对象,添加到更新队列diffQueue。</span></div><div class="line">ReactDOMComponent.prototype._diff = <span class="function"><span class="keyword">function</span>(<span class="params">diffQueue, nextChildrenElements</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">  <span class="comment">//拿到之前的子节点的 component类型对象的集合,这个是在刚开始渲染时赋值的</span></div><div class="line">  <span class="comment">//_renderedChildren 本来是数组，我们搞成map</span></div><div class="line">  <span class="keyword">var</span> prevChildren = flattenChildren(self._renderedChildren);</div><div class="line">  <span class="comment">//生成新的子节点的component对象集合，这里注意，会复用老的component对象</span></div><div class="line">  <span class="keyword">var</span> nextChildren = generateComponentChildren(prevChildren, nextChildrenElements);</div><div class="line">  <span class="comment">//重新赋值_renderedChildren，使用最新的。</span></div><div class="line">  self._renderedChildren = []</div><div class="line">  $.each(nextChildren, <span class="function"><span class="keyword">function</span>(<span class="params">key, instance</span>) </span>&#123;</div><div class="line">    self._renderedChildren.push(instance);</div><div class="line">  &#125;)</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">var</span> nextIndex = <span class="number">0</span>; <span class="comment">//代表到达的新的节点的index</span></div><div class="line">  <span class="comment">//通过对比两个集合的差异，组装差异节点添加到队列中</span></div><div class="line">  <span class="keyword">for</span> (name <span class="keyword">in</span> nextChildren) &#123;</div><div class="line">    <span class="keyword">if</span> (!nextChildren.hasOwnProperty(name)) &#123;</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> prevChild = prevChildren &amp;&amp; prevChildren[name];</div><div class="line">    <span class="keyword">var</span> nextChild = nextChildren[name];</div><div class="line">    <span class="comment">//相同的话，说明是使用的同一个component,所以我们需要做移动的操作</span></div><div class="line">    <span class="keyword">if</span> (prevChild === nextChild) &#123;</div><div class="line">      <span class="comment">//添加差异对象，类型：MOVE_EXISTING</span></div><div class="line">      diffQueue.push(&#123;</div><div class="line">        <span class="attr">parentId</span>: self._rootNodeID,</div><div class="line">        <span class="attr">parentNode</span>: $(<span class="string">'[data-reactid='</span> + self._rootNodeID + <span class="string">']'</span>),</div><div class="line">        <span class="attr">type</span>: UPATE_TYPES.MOVE_EXISTING,</div><div class="line">        <span class="attr">fromIndex</span>: prevChild._mountIndex,</div><div class="line">        <span class="attr">toIndex</span>: nextIndex</div><div class="line">      &#125;)</div><div class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果不相同，说明是新增加的节点</span></div><div class="line">      <span class="comment">//但是如果老的还存在，就是element不同，但是component一样。我们需要把它对应的老的element删除。</span></div><div class="line">      <span class="keyword">if</span> (prevChild) &#123;</div><div class="line">        <span class="comment">//添加差异对象，类型：REMOVE_NODE</span></div><div class="line">        diffQueue.push(&#123;</div><div class="line">          <span class="attr">parentId</span>: self._rootNodeID,</div><div class="line">          <span class="attr">parentNode</span>: $(<span class="string">'[data-reactid='</span> + self._rootNodeID + <span class="string">']'</span>),</div><div class="line">          <span class="attr">type</span>: UPATE_TYPES.REMOVE_NODE,</div><div class="line">          <span class="attr">fromIndex</span>: prevChild._mountIndex,</div><div class="line">          <span class="attr">toIndex</span>: <span class="literal">null</span></div><div class="line">        &#125;)</div><div class="line"></div><div class="line">        <span class="comment">//如果以前已经渲染过了，记得先去掉以前所有的事件监听，通过命名空间全部清空</span></div><div class="line">        <span class="keyword">if</span> (prevChild._rootNodeID) &#123;</div><div class="line">            $(<span class="built_in">document</span>).undelegate(<span class="string">'.'</span> + prevChild._rootNodeID);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">      &#125;</div><div class="line">      <span class="comment">//新增加的节点，也组装差异对象放到队列里</span></div><div class="line">      <span class="comment">//添加差异对象，类型：INSERT_MARKUP</span></div><div class="line">      diffQueue.push(&#123;</div><div class="line">        <span class="attr">parentId</span>: self._rootNodeID,</div><div class="line">        <span class="attr">parentNode</span>: $(<span class="string">'[data-reactid='</span> + self._rootNodeID + <span class="string">']'</span>),</div><div class="line">        <span class="attr">type</span>: UPATE_TYPES.INSERT_MARKUP,</div><div class="line">        <span class="attr">fromIndex</span>: <span class="literal">null</span>,</div><div class="line">        <span class="attr">toIndex</span>: nextIndex,</div><div class="line">        <span class="attr">markup</span>: nextChild.mountComponent() <span class="comment">//新增的节点，多一个此属性，表示新节点的dom内容</span></div><div class="line">      &#125;)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//更新mount的index</span></div><div class="line">    nextChild._mountIndex = nextIndex;</div><div class="line">    nextIndex++;</div><div class="line">  &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">//对于老的节点里有，新的节点里没有的那些，也全都删除掉</span></div><div class="line">  <span class="keyword">for</span> (name <span class="keyword">in</span> prevChildren) &#123;</div><div class="line">    <span class="keyword">if</span> (prevChildren.hasOwnProperty(name) &amp;&amp; !(nextChildren &amp;&amp; nextChildren.hasOwnProperty(name))) &#123;</div><div class="line">      <span class="comment">//添加差异对象，类型：REMOVE_NODE</span></div><div class="line">      diffQueue.push(&#123;</div><div class="line">        <span class="attr">parentId</span>: self._rootNodeID,</div><div class="line">        <span class="attr">parentNode</span>: $(<span class="string">'[data-reactid='</span> + self._rootNodeID + <span class="string">']'</span>),</div><div class="line">        <span class="attr">type</span>: UPATE_TYPES.REMOVE_NODE,</div><div class="line">        <span class="attr">fromIndex</span>: prevChild._mountIndex,</div><div class="line">        <span class="attr">toIndex</span>: <span class="literal">null</span></div><div class="line">      &#125;)</div><div class="line">      <span class="comment">//如果以前已经渲染过了，记得先去掉以前所有的事件监听</span></div><div class="line">      <span class="keyword">if</span> (prevChildren[name]._rootNodeID) &#123;</div><div class="line">        $(<span class="built_in">document</span>).undelegate(<span class="string">'.'</span> + prevChildren[name]._rootNodeID);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="patch的实现"><a href="#patch的实现" class="headerlink" title="__patch的实现"></a>__patch的实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//用于将childNode插入到指定位置</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertChildAt</span>(<span class="params">parentNode, childNode, index</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> beforeChild = parentNode.children().get(index);</div><div class="line">    beforeChild ? childNode.insertBefore(beforeChild) : childNode.appendTo(parentNode);</div><div class="line">&#125;</div><div class="line"></div><div class="line">ReactDOMComponent.prototype._patch = <span class="function"><span class="keyword">function</span>(<span class="params">updates</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> update;</div><div class="line">    <span class="keyword">var</span> initialChildren = &#123;&#125;;</div><div class="line">    <span class="keyword">var</span> deleteChildren = [];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; updates.length; i++) &#123;</div><div class="line">        update = updates[i];</div><div class="line">        <span class="keyword">if</span> (update.type === UPATE_TYPES.MOVE_EXISTING || update.type === UPATE_TYPES.REMOVE_NODE) &#123;</div><div class="line">            <span class="keyword">var</span> updatedIndex = update.fromIndex;</div><div class="line">            <span class="keyword">var</span> updatedChild = $(update.parentNode.children().get(updatedIndex));</div><div class="line">            <span class="keyword">var</span> parentID = update.parentID;</div><div class="line"></div><div class="line">            <span class="comment">//所有需要更新的节点都保存下来，方便后面使用</span></div><div class="line">            initialChildren[parentID] = initialChildren[parentID] || [];</div><div class="line">            <span class="comment">//使用parentID作为简易命名空间</span></div><div class="line">            initialChildren[parentID][updatedIndex] = updatedChild;</div><div class="line"></div><div class="line"></div><div class="line">            <span class="comment">//所有需要修改的节点先删除,对于move的，后面再重新插入到正确的位置即可</span></div><div class="line">            deleteChildren.push(updatedChild)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//删除所有需要先删除的</span></div><div class="line">    $.each(deleteChildren, <span class="function"><span class="keyword">function</span>(<span class="params">index, child</span>) </span>&#123;</div><div class="line">        $(child).remove();</div><div class="line">    &#125;)</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">//再遍历一次，这次处理新增的节点，还有修改的节点这里也要重新插入</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; updates.length; k++) &#123;</div><div class="line">        update = updates[k];</div><div class="line">        <span class="keyword">switch</span> (update.type) &#123;</div><div class="line">            <span class="keyword">case</span> UPATE_TYPES.INSERT_MARKUP:</div><div class="line">                insertChildAt(update.parentNode, $(update.markup), update.toIndex);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> UPATE_TYPES.MOVE_EXISTING:</div><div class="line">                insertChildAt(update.parentNode, initialChildren[update.parentID][update.fromIndex], update.toIndex);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> UPATE_TYPES.REMOVE_NODE:</div><div class="line">                <span class="comment">// 什么都不需要做，因为上面已经帮忙删除掉了</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="差异更新类型"><a href="#差异更新类型" class="headerlink" title="差异更新类型"></a>差异更新类型</h4><ul>
<li>MOVE_EXISTING: 新的component类型在老的集合里也有，并且element是可以更新的类型，在generateComponentChildren我们已经调用了receiveComponent，这种情况下prevChild=nextChild,那我们就需要做出移动的操作，可以复用以前的dom节点。</li>
<li>INSERT_MARKUP: 新的component类型不在老的集合里，那么就是全新的节点，我们需要插入新的节点</li>
<li>REMOVE_NODE: 老的component类型，在新的集合里也有，但是对应的element不同了不能直接复用直接更新，那我们也得删除。</li>
<li>REMOVE_NODE: 老的component不在新的集合里的，我们需要删除。</li>
</ul>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/React-ES6/" rel="tag"># -React -ES6</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/12/07/guide-paper/" rel="prev" title="使用说明">
                使用说明 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/logo.png"
               alt="osxfe" />
          <p class="site-author-name" itemprop="name">osxfe</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、React简介"><span class="nav-number">1.</span> <span class="nav-text">一、React简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、Virtual-DOM"><span class="nav-number">1.1.</span> <span class="nav-text">1、Virtual DOM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、组件化"><span class="nav-number">1.2.</span> <span class="nav-text">2、组件化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#React组件应具有如下特征"><span class="nav-number">1.2.1.</span> <span class="nav-text">React组件应具有如下特征</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、React原理分析"><span class="nav-number">2.</span> <span class="nav-text">二、React原理分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ReactJs的核心内容主要包括"><span class="nav-number">2.0.1.</span> <span class="nav-text">ReactJs的核心内容主要包括</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1、ReactJs首次渲染"><span class="nav-number">2.1.</span> <span class="nav-text">1、ReactJs首次渲染</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#文本节点渲染"><span class="nav-number">2.1.1.</span> <span class="nav-text">文本节点渲染</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基本元素渲染"><span class="nav-number">2.1.2.</span> <span class="nav-text">基本元素渲染</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自定义元素渲染"><span class="nav-number">2.1.3.</span> <span class="nav-text">自定义元素渲染</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、更新机制"><span class="nav-number">2.2.</span> <span class="nav-text">2、更新机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#自定义元素的receiveComponent"><span class="nav-number">2.2.1.</span> <span class="nav-text">自定义元素的receiveComponent</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#更新属性"><span class="nav-number">2.2.2.</span> <span class="nav-text">更新属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#diff实现"><span class="nav-number">2.2.3.</span> <span class="nav-text">_diff实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#patch的实现"><span class="nav-number">2.2.4.</span> <span class="nav-text">__patch的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#差异更新类型"><span class="nav-number">2.2.5.</span> <span class="nav-text">差异更新类型</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">osxfe</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

</body>
</html>
