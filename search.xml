<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SourceMap In Action | SourceMap 实践]]></title>
    <url>%2F2017%2F12%2F23%2Fsourcemap-in-action%2F</url>
    <content type="text"><![CDATA[SourceMap 解析资料： SourceMap文件格式 http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html http://www.alloyteam.com/2014/01/source-map-version-3-introduction/ 如何映射 本地保存文件映射，本地保存文件 直接在文件末尾注明位置 以JS为例: //@ sourceMappingURL=target.js.map 自己按照URL去映射，对解析工具必须可访问 JS 异常如何解析prototype: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/prototype 12345678910Error.prototypeError.prototype.columnNumber : 非标准Error.prototype.fileName : 非标准Error.prototype.lineNumber: 非标准Error.prototype.messageError.prototype.nameError.prototype.stackMethodsError.prototype.toSource(): 非标准Error.prototype.toString() stack属性 定位位置 = 解析Error.prototype.stack 构造: new Error(name) 默认toString = e.type : e.name e.stack = toString()\n + stack frames 过程：解析stack frames -&gt; 获取sourcemap -&gt; consumeSourceMap -&gt; 获取Mapping 结果1TypeError: Cannot read property \&apos;toDate\&apos; of undefined @ Object.onChange (https://osx.dpfile.com/app/overseas-bc-static/static/orderdetails.e91e32130b4a54ea9f01.js:1:722437) @ t.n.handleChange (https://osx.dpfile.com/app/overseas-bc-static/static/dll.min.d1c4244bfbd687f19b9c4c171fd79de1.js:1:918483) @ n.clearSelection (https://osx.dpfile.com/app/overseas-bc-static/static/dll.min.d1c4244bfbd687f19b9c4c171fd79de1.js:1:918308) @ Object.r (https://osx.dpfile.com/app/overseas-bc-static/static/dll.min.d1c4244bfbd687f19b9c4c171fd79de1.js:1:211791) @ i (https://osx.dpfile.com/app/overseas-bc-static/static/dll.min.d1c4244bfbd687f19b9c4c171fd79de1.js:1:210137) @ Object.s [as executeDispatchesInOrder] (https://osx.dpfile.com/app/overseas-bc-static/static/dll.min.d1c4244bfbd687f19b9c4c171fd79de1.js:1:210327) @ p (https://osx.dpfile.com/app/overseas-bc-static/static/dll.min.d1c4244bfbd687f19b9c4c171fd79de1.js:1:175391) @ m (https://osx.dpfile.com/app/overseas-bc-static/static/dll.min.d1c4244bfbd687f19b9c4c171fd79de1.js:1:175517)]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用说明]]></title>
    <url>%2F2017%2F12%2F21%2Fguide-paper%2F</url>
    <content type="text"><![CDATA[请按以下步骤发表博文: 1、全局安装hexo1$ npm install hexo -g 2、Clone 源代码master分支存放编译后的代码（html, js, css）,该分支不要改动。source分支存放源代码包含Markdown文件, 需要编写发布博文,请先切换到该分支。 仓库地址:&nbsp;&nbsp;&nbsp;&nbsp;https://github.com/osxfe/osxfe.github.io 3、新建博文1$ hexo new "My New Blog" 4、本地调试1$ hexo server 5、生成静态文件1$ hexo generate 6、发布1$ hexo deploy]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hash规则]]></title>
    <url>%2F2017%2F12%2F07%2FHash%E8%A7%84%E5%88%99%2F</url>
    <content type="text"><![CDATA[Hash规则B端hash问题1、原本主文档引用的文件，hash生成交由CI处理，但是资源路径配置错误，导致CI替换失败，异步脚本正常更新，但是主文档中引用的是老的文件。 2、chunk文件内容未修改，引用的module Id有变更，但是hash值未更新，导致新老版本加载报错。 3、为了解决CDN上缓存了错误的文件版本hash的问题，引入了webpack-md5-hash重新生成了文件hash规则。 4、发现webpack-md5-hash插件本身hash策略有问题：module id改变或者异步chunk改变，都不会更新hash值，导致错误的引用。 基础概念1、hash与chunkHash的区别文件的hash指纹通常作为前端静态资源实现增量更新的方案之一，在Webpack编译输出文件的配置过程中，如果需要为文件加入hash指纹，Webpack提供了两个配置项可供使用：hash和chunkhash。那么两者有何区别呢？其各自典型的应用场景又是什么？ 首先我们先看一下官方文档对于两者的定义： [hash] is replaced by the hash of the compilation. hash代表的是compilation的hash值。 [chunkhash] is replaced by the hash of the chunk. chunkhash代表的是chunk的hash值。 chunkhash很好理解，chunk在Webpack中的含义我们都清楚，简单讲，chunk就是模块。chunkhash也就是根据模块内容计算出的hash值。 那么该如何理解hash是compilation的hash值这句话呢？首先先讲解一下Webpack中compilation的含义。 1.1、compilationWebpack官方文档中How to write a plugin章节有对compilation的详解。 A compilation object represents a single build of versioned assets. While running Webpack development middleware, a new compilation will be created each time a file change is detected, thus generating a new set of compiled assets. A compilation surfaces information about the present state of module resources, compiled assets, changed files, and watched dependencies. compilation对象代表某个版本的资源对应的编译进程。当使用Webpack的development中间件时，每次检测到项目文件有改动就会创建一个compilation，进而能够针对改动生产全新的编译文件。compilation对象包含当前模块资源、待编译文件、有改动的文件和监听依赖的所有信息。 与compilation对应的有个compiler对象，通过对比，可以帮助大家对compilation有更深入的理解。 1.2、compiler The compiler object represents the fully configured Webpack environment. This object is built once upon starting Webpack, and is configured with all operational settings including options, loaders, and plugins. compiler对象代表的是配置完备的Webpack环境。 compiler对象只在Webpack启动时构建一次，由Webpack组合所有的配置项构建生成。 简单的讲，compiler对象代表的是不变的webpack环境，是针对webpack的；而compilation对象针对的是随时可变的项目文件，只要文件有改动，compilation就会被重新创建。 1.3、使用对比compilation在项目中任何一个文件改动后就会被重新创建，然后webpack计算新的compilation的hash值，这个hash值便是hash。 如果使用hash作为编译输出文件的hash指纹的话，如下： 1234output: &#123; filename: '[name].[hash:8].js', path: __dirname + '/build'&#125; hash是compilation对象计算所得，而不是具体的项目文件计算所得。所以以上配置的编译输出文件，所有的文件名都会使用相同的hash指纹。如下： 这样带来的问题是，三个js文件任何一个改动都会影响另外两个文件的最终文件名。上线后，另外两个文件的浏览器缓存也全部失效。这肯定不是我们想要的结果。 那么如何避免这个问题呢？答案就是chunkhash！ 根据chunkhash的定义知道，chunkhash是根据具体模块文件的内容计算所得的hash值，所以某个文件的改动只会影响它本身的hash指纹，不会影响其他文件。配置webpack的output如下： 1234output: &#123; filename: '[name].[chunkhash:8].js', path: __dirname + '/build'&#125; 编译输出的文件为： 每个文件的hash指纹都不相同，上线后无改动的文件不会失去缓存。 不要在开发环境使用 [chunkhash]/[hash]/[contenthash]，因为不需要在开发环境做持久缓存，而且这样会增加编译时间，开发环境用 [name] 就可以了。 2、contenthashwebpack将style视为js的一部分，所以在计算chunkhash时，会把所有的js代码和style代码混合在一起计算。比如main.js引用了main.scss: 12import &apos;main.scss&apos;;alert(&apos;I am main.js&apos;); main.scss的内容如下： 123body&#123; color: #000;&#125; webpack计算chunkhash时，以main.js文件为编译入口，整个chunk的内容会将main.scss的内容也计算在内： 1234body&#123; color: #000;&#125;alert(&apos;I am main.js&apos;); 所以，不论是修改了js代码还是scss代码，整个chunk的内容都改变了，计算所得的chunkhash自然就不同了。 我们一般会通过extract-text-webpack-plugin将样式文件单独抽取出来，但是不管是不是抽取出来了，chunkhash的计算方式还是合在一起算的， js 和 css 输出的文件用的是同一个 chunkhash，所以还是会存在问题。不过，该插件提供了另外一种hash值：contenthash。 顾名思义，contenthash代表的是文本文件内容的hash值，也就是只有style文件的hash值。 1new ExtractTextPlugin(&apos;[name].[contenthash].css&apos;); 这样，编译出来的js和css文件将会有独立的hash指纹。并且如果我们只是修改了js代码，css的hash值也不会变化的。 但是，反过来看，当我们如果修改css文件的时候，会发现js的hash还是会变化，还是因为之前提到的，chunkhash会计算js和css为入口，就算css已经提出去了。那么怎么去解决呢？ 3、入坑webpack-md5-hashwebpack-md5-hash做了些什么？这里提到一个概念叫chunk-hash，并不是webpack中另一种hash值，而是compilation执行生命周期中的一个钩子。 1this.applyPlugins(&quot;chunk-hash&quot;, chunk, chunkHash); chunk-hash是在chunhash计算完毕之后执行的，这就意味着如果我们在chunk-hash钩子中可以用新的chunkhash替换已存在的值。webpack-md5-hash便是如此实现的，用了另外一种计算方式，去生成hash值。 看上去一切都很美好，使用了webpack-md5-hash之后，我们去修改css文件的时候，会发现js的hash没有发生变化。那么webpack-md5-hash到底做了些什么？ 3.1 webpack-md5-hash做了什么？ 通过模块路径来排序 chunk 的所有依赖模块（仅这个 chunk 中的模块，不含被 CommonsChunkPlugin 剔除的模块），并将这些排序后的模块源代码拼接，最后用 MD5 拼接后内容的 chunkhash。插件这么做的好处是，使 chunkhash 与该 chunk 内代码做直接关联，让 chunk 与其依赖的模块 ID 无关化，无论模块 ID 如何变化，都不会影响父 chunk 的实质内容及 chunkhash。 3.2 存在的问题？ 当仅有modules id发生改变的时候，hash值不会发生变化（https://github.com/erm0l0v/webpack-md5-hash/issues/7 ） 它的计算方法是只计算模块本身的当前内容（包括同步模块），也就是上文的代码。这种计算方式把异步模块的内容忽略掉了。也就是说，主文件计算hash值时没有把异步模块的内容计算在内。 3.3 异步模块问题如何导致的?例如：入口文件main.app.js的代码如下： 12345678import &apos;../style/main.app.scss&apos;;console.log(&apos;main&apos;);window.onload = function()&#123; require.ensure([],(require)=&gt;&#123; require(&apos;./part.a.js&apos;); &#125;);&#125; 异步模块part.a.js代码如下： 123456console.log(&apos;part a&apos;);setTimeout(()=&gt;&#123; require.ensure([],(require)=&gt;&#123; require(&apos;./part.b.js&apos;); &#125;);&#125;,10000); 异步模块part.b.js代码如下： 1234import fn_c from &apos;./part.c.js&apos;;import fn_d from &apos;./part.d.js&apos;;console.log(&apos;part b&apos;); 使用webpack将以上源代码进行编译，输出以下文件： main.app.[chunkhash].js：主文件； part.a.[chunkhash].js：异步模块a； part.b.[chunkhash].js：异步模块b； main.app.[chunkhash].css：样式文件。 如果我们修改了part.a.js源码，编译的结果文件哪些文件的hash改变了？ 答案是：只有part.a.[chunkhash].js的hash改变了，其余文件的hash都与修改前一致。那么这种结果是否合理呢？ 我们首先了解一下webpack runtime是如何加载异步模块的？ 123456789101112131415var head = document.getElementsByTagName(&apos;head&apos;)[0];var script = document.createElement(&apos;script&apos;);script.type = &apos;text/javascript&apos;;script.charset = &apos;utf-8&apos;;script.async = true;script.src = __webpack_require__.p + &quot;js/part/part.&quot; + (&#123; &quot;1&quot;: &quot;a&quot;, &quot;2&quot;: &quot;b&quot; &#125;[chunkId] || chunkId) + &quot;.&quot; + &#123; &quot;1&quot;: &quot;f5ea7d95&quot;, &quot;2&quot;: &quot;b93662b0&quot;&#125;[chunkId] + &quot;.js&quot;;head.appendChild(script); 上述代码是编译生成的main.app.[chunkhash].js中实现懒加载的逻辑，原理就是大家熟知的动态生成script标签。但是在对script.src赋值时，webpack有以下三个概念需要知晓： chunkId，对应上述代码中的”1”和”2”； chunkName，对应上述代码中的”a”和”b”； chunkHash，对应上述代码中的”f5ea7d95”和”b93662b0”。 也就是说，part.a.[chunkhash].js和part.b.[chunkhash].js的hash值是写死在main.app.[chunkhash].js中的。按照之前的编译结果，part.a.[chunkhash].js的hash变了，但是main.app.[chunkhash].js的hash没变，那么用户的浏览器仍然缓存着旧版本的main.app.[chunkhash].js，此时异步加载的part.a.[chunkhash].js仍然是旧版本的文件。这显然是不符合需求的。 因此懒加载模块的改动经编译，去引用的主文件的hash值没有变化，影响了版本发布。所以建议在采用这种插件的时候，一定要搞清楚它的原理和做的事情，否则容易入坑。 4、不稳定的chunkhash计算 chunk MD5 摘要并修改 chunk 资源文件名是不够的，Chunk 的生成还涉及到依赖解析和模块 ID 分配，例如：我们都会在 webpack 里面定义 common chunk 提取公共代码，虽然只修改了 app.js 的代码，但在最终的构建结果中，vendor.js 的 chunkhash 也被修改了，尽管 vendor.js 的内容没有实质变化。这样我们无法提高缓存的利用率。 4.1、编译中会导致缓存失效的因素在一个 webpack 编译出的分块 (chunk) 文件中，内容分为如下四部分： 包含的模块的源代码 webpack 生成的模块 id (module id) (包括包含的模块 id, 以及该模块引用的依赖模块的 id) webpack 用于启动运行的 bootstrap runtime Chunk ID 那块这些情况会导致缓存失效： 1、源代码的变更这个不说了 2、webpack 生成的模块 id变动12345678910111213141516171819(function (modules) &#123; // webpackBootstrap // ...&#125;)([/* 0 *//***/ function(module, exports, __webpack_require__) &#123; __webpack_require__(1); module.exports = &apos;entry_1.js&apos;;/***/ &#125;,/* 1 *//***/ function(module, exports, __webpack_require__) &#123; __webpack_require__(2); module.exports = &apos;test_1.js&apos;;/***/ &#125;,/* 2 *//***/ function(module, exports) &#123; module.exports = &apos;test_2.js&apos;;/***/ &#125;/******/ ]) 如上，注释中的 / 0 / … / 1 / … 就是该模块对应的 id。默认，模块的 ID 是 webpack 根据依赖的收集顺序递增的正整数，这种 ID 分配方式不太稳定，。假设新增/删除一个模块引用，或者依赖的顺序变一下，计算结果就可能变化，导致一些模块 id 发生变化，最终导致输出 chunk 变化，缓存失效。这一条几乎会导致所有输出的分块内容都发生变化。 如何解决这个问题？ 我们需要固定id的计算方式，那么一个模块文件的什么信息是固定的？ —–文件路径可以使用两个插件来解决这个问题： NamedModulesPlugin HashedModuleIdsPlugin他们都已经被添加到了webpack中，可以直接使用： 1new webpack.HashedModuleIdsPlugin() 前者将递增 ID 替换为模块相对路径，可读性强，不过，构建出来的 chunk 会充满各种路径，使文件增大。后者是前者的进阶模块，它在其基础上对模块路径进行 MD5 摘要。到此module id的生成规则稳定下来。 3、webpack bootstrap runtime 变动上面的代码里 / 0 / … / 1 / … 对应的都是模块定义，要让程序运行起来还需要一小段启动代码，这个就是 webpack bootstrap runtime，它长这样： 12345678910111213141516171819202122232425262728293031323334353637383940(function(modules) &#123; // webpackBootstrap/******/ // The module cache/******/ var installedModules = &#123;&#125;;/******/ // The require function/******/ function __webpack_require__(moduleId) &#123;/******/ // Check if module is in cache/******/ if(installedModules[moduleId])/******/ return installedModules[moduleId].exports;/******/ // Create a new module (and put it into the cache)/******/ var module = installedModules[moduleId] = &#123;/******/ exports: &#123;&#125;,/******/ id: moduleId,/******/ loaded: false/******/ &#125;;/******/ // Execute the module function/******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);/******/ // Flag the module as loaded/******/ module.loaded = true;/******/ // Return the exports of the module/******/ return module.exports;/******/ &#125;/******/ // expose the modules object (__webpack_modules__)/******/ __webpack_require__.m = modules;/******/ // expose the module cache/******/ __webpack_require__.c = installedModules;/******/ // __webpack_public_path__/******/ __webpack_require__.p = &quot;/build/&quot;;/******/ // Load entry module and return exports/******/ return __webpack_require__(0);/******/ &#125;)(/* modules */) 其他的都是配置项，启动程序的代码在这一个函数的最后一行：return webpack_require(0);，立即执行 id 为0的模块。 这么看好像每次编译的时候这个 runtime 不会有什么变化，然而实际项目中往往为了缓存利用率以及按需加载引入了多个分块 (chunk)，包括公共分块和按需加载的分块。我们可以看到： 1234567891011121314151617181920212223/******/ // This file contains only the entry chunk./******/ // The chunk loading function for additional chunks/******/ __webpack_require__.e = function requireEnsure(chunkId, callback) &#123;/******/ // &quot;0&quot; is the signal for &quot;already loaded&quot;/******/ if(installedChunks[chunkId] === 0)/******/ return callback.call(null, __webpack_require__);/******/ // an array means &quot;currently loading&quot;./******/ if(installedChunks[chunkId] !== undefined) &#123;/******/ installedChunks[chunkId].push(callback);/******/ &#125; else &#123;/******/ // start chunk loading/******/ installedChunks[chunkId] = [callback];/******/ var head = document.getElementsByTagName(&apos;head&apos;)[0];/******/ var script = document.createElement(&apos;script&apos;);/******/ script.type = &apos;text/javascript&apos;;/******/ script.charset = &apos;utf-8&apos;;/******/ script.async = true;/******/ script.src = __webpack_require__.p + &quot;&quot; + chunkId + &quot;.&quot; + (&#123;&quot;0&quot;:&quot;e_1&quot;,&quot;1&quot;:&quot;e_2&quot;&#125;[chunkId]||chunkId) + &quot;.&quot; + &#123;&quot;0&quot;:&quot;d0c1831ff024c3aeb47a&quot;,&quot;1&quot;:&quot;50dc9cf2b5e52bc9e61a&quot;&#125;[chunkId] + &quot;.js&quot;;/******/ head.appendChild(script);/******/ &#125;/******/ &#125;; 这个时候我们可以看看到，最后会有一个文件名映射表，它包含chunks ID 及其对应 chunkhash 的对象，那么runtime 中的文件名映射就跟着改了，这个分块也就被修改了。 如何解决这个问题？runtime中变动的就是其中的文件名信息，我们把这总是变动的部分单独拎出来，不要让它影响公共分块或者入口分块。CommonsChunkPlugin可以帮我们抽取出来： CommonsChunkPlugin 可以用于将模块分离到单独的文件中。然而 CommonsChunkPlugin 有一个较少有人知道的功能是，能够在每次修改后的构建结果中，将 webpack 的样板(boilerplate)和 manifest 提取出来。通过指定 entry 配置中未用到的名称，此插件会自动将我们需要的内容提取到单独的包中： 12345678new webpack.optimize.CommonsChunkPlugin(&#123; name: &apos;vendor&apos;, minChunks: Infinity&#125;),new webpack.optimize.CommonsChunkPlugin(&#123; name: &apos;manifest&apos;&#125;), 这样就会生成一个特别小（不足 2kb）的 manifest.js解决了 libs 经常被更新的问题。同时我们可以使用inline-manifest-webpack-plugin将 manifest 转为内联在 html 内的 inline script 4、Chunk ID变动123456789101112131415webpackJsonp([0,1],[/* 0 *//***/ function(module, exports, __webpack_require__) &#123; __webpack_require__(1); module.exports = &apos;entry.js&apos;;/***/ &#125;,/* 1 *//***/ function(module, exports) &#123; module.exports = &apos;test.js&apos;;/***/ &#125;]); 这里函数调用的第一个参数 [0,1] 就对应了这个分块的 id。同模块 id 一样, 分块 id 的计算与分块引入顺序有关，官方有提供NamedChunksPlugin插件来根据文件名来稳定你的chunkid。 1new webpack.NamedChunksPlugin() 5、总结123456789101112131415161718192021222324252627output: &#123; filename: &apos;[name].[chunkhash].js&apos;, chunkFilename: &apos;[name].[chunkhash].js&apos;&#125;,plugins: [ // 单独提取 webpack runtime manifest new webpack.optimize.CommonsChunkPlugin(&#123; name: &apos;manifest&apos; &#125;), new HtmlWebpackPlugin(&#123; template: &apos;src/pages/index.ejs&apos;, chunks: [&apos;manifest&apos;, &apos;vendor&apos;] &#125;), //内联manifest new InlineManifestWebpackPlugin(), // 用文件路径当 id，固定module id new webpack.HashedModuleIdsPlugin(), // 文件名固定chunk id new webpack.NamedChunksPlugin(), //css 输出按实际内容计算 hash new ExtractTextWebpackPlugin(&#123;filename: &apos;[name].[contenthash].css&apos;&#125;),]]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>-Webpack -ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React原理浅谈]]></title>
    <url>%2F2017%2F07%2F17%2FReact%2F</url>
    <content type="text"><![CDATA[一、React简介1、Virtual DOMReact为此引入了虚拟DOM的机制，在浏览器端用Javascript实现了一套DOM API。基于React进行开发时所有的DOM构造都是通过虚拟DOM进行，每当数据变化时，React都会重新构建整个DOM树，然后React将当前整个DOM树和上一次的DOM树进行对比，得到DOM结构的区别，然后仅仅将需要变化的部分进行实际的浏览器DOM更新。 2、组件化组件是封装起来的具有独立功能的UI部件 React组件应具有如下特征 可组合(Composeable): 一个组件易于和其它组件一起使用，或者嵌套在另一个组件内部;如果一个组件内部创建了另一个组件，那么说父组件拥有（own）它创建的子组件，通过这个特性，一个复杂的UI可以拆分成多个简单的UI组件 可重用(Reusable): 每个组件都是具有独立功能的，它可以被使用在多个UI场景 可维护(Maintainable): 每个小的组件仅仅包含自身的逻辑，更容易被理解和维护 二、React原理分析ReactJs的核心内容主要包括 虚拟dom对象(Virtual DOM) 虚拟dom差异化算法（diff algorithm） 单向数据流渲染（Data Flow） 组件生命周期 事件处理 1、ReactJs首次渲染 虚拟dom元素分为两种，一种是浏览器自带的基本元素比如 div p input form 这种，一种是自定义的元素。文本节点，不算虚拟dom，但是ReacJs为了保持渲染的一致性, 在文本节点外面包了一层span标记，形成简化版的component（ReactDOMTextComponent）。 文本节点渲染123456789101112131415161718192021222324252627282930313233//component类，用来表示文本在渲染，更新，删除时应该做些什么事情function ReactDOMTextComponent(text) &#123; //存下当前的字符串 this._currentElement = '' + text; //用来标识当前component this._rootNodeID = null;&#125;//component渲染时生成的dom结构ReactDOMTextComponent.prototype.mountComponent = function(rootID) &#123; this._rootNodeID = rootID; return '&lt;span data-reactid="' + rootID + '"&gt;' + this._currentElement + '&lt;/span&gt;';&#125;//component工厂 用来返回一个component实例function instantiateReactComponent(node)&#123; if(typeof node === 'string' || typeof node === 'number')&#123; return new ReactDOMTextComponent(node) &#125;&#125;React = &#123; nextReactRootIndex:0, render:function(element,container)&#123; var componentInstance = instantiateReactComponent(element); var markup = componentInstance.mountComponent(React.nextReactRootIndex++); $(container).html(markup); //触发完成mount的事件 $(document).trigger('mountReady'); &#125;&#125; React.render 作为入口负责调用渲染 ReactDOMTextComponent是一个component类定义，定义对于这种文本类型的节点，在渲染，更新，删除时应该做什么操作 instantiateReactComponent用来根据element的类型（现在只有一种string类型），返回一个component的实例。其实就是个类工厂 基本元素渲染在React中使用React.createElement来创建一个虚拟dom元素, 例如:12345678function hello()&#123; alert('hello')&#125;var element = React.createElement('div',&#123;id:'test',onclick:hello&#125;,'click me')React.render(element,document.getElementById("container")) 当render的不是文本而是浏览器的基本元素时，使用另外一种component来处理它渲染时应该返回的内容，由于使用的是工厂方法instantiateReactComponent，不管来了什么类型的node，都可以负责生产出一个负责渲染的component实例。这样render完全不需要做任何修改，只需要再做一种对应的component类型ReactDOMComponent就行了。虚拟dom的渲染逻辑，本质上还是个递归渲染的东西，reactElement会递归渲染自己的子节点。可以看到我们通过instantiateReactComponent屏蔽了子节点的差异，只需要使用不同的componet类，这样都能保证通过mountComponent最终拿到渲染后的内容。 自定义元素渲染随着前端技术的发展浏览器的那些基本元素已经满足不了我们的需求了，ReactJs的element.type可以是简单的字符串也可以是个类，而且这个类还有自己的生命周期管理。 生命周期共提供了10个不同的API1.getDefaultProps2.getInitialState3.componentWillMount4.render5.componentDidMount6.componentWillReceiveProps7.shouldComponentUpdate8.componentWillUpdate9.componentDidUpdate10.componentWillUnmount 自定义元素,React.createElement接受的不再是字符串，而是一个class12345678910111213141516var HelloMessage = React.createClass(&#123; getInitialState: function() &#123; return &#123;type: 'say:'&#125;; &#125;, componentWillMount: function() &#123; console.log('我就要开始渲染了。。。') &#125;, componentDidMount: function() &#123; console.log('我已经渲染好了。。。') &#125;, render: function() &#123; return React.createElement("div", null,this.state.type, "Hello ", this.props.name); &#125;&#125;);React.render(React.createElement(HelloMessage, &#123;name: "John"&#125;), document.getElementById("container")); React.createClass生成一个自定义标记类，带有基本的生命周期： getInitialState 获取最初的属性值this.state componentWillmount 在组件准备渲染时调用 componentDidMount 在组件渲染完成后调用 通过上面的两种类型知道，需要未自定义元素也提供一个componet类，在这个类里我们会实例化ReactClass，并且管理生命周期，还有父子组件依赖。 12345678910111213141516171819202122232425262728293031323334353637383940414243function ReactCompositeComponent(element)&#123; //存放元素element对象 this._currentElement = element; //存放唯一标识 this._rootNodeID = null; //存放对应的ReactClass的实例 this._instance = null;&#125;//用于返回当前自定义元素渲染时应该返回的内容ReactCompositeComponent.prototype.mountComponent = function(rootID)&#123; this._rootNodeID = rootID; //拿到当前元素对应的属性值 var publicProps = this._currentElement.props; //拿到对应的ReactClass var ReactClass = this._currentElement.type; // Initialize the public class var inst = new ReactClass(publicProps); this._instance = inst; //保留对当前comonent的引用，下面更新会用到 inst._reactInternalInstance = this; if (inst.componentWillMount) &#123; inst.componentWillMount(); //这里在原始的reactjs其实还有一层处理，就是 componentWillMount调用setstate，不会触发rerender而是自动提前合并，这里为了保持简单，就略去了 &#125; //调用ReactClass的实例的render方法,返回一个element或者一个文本节点 var renderedElement = this._instance.render(); //得到renderedElement对应的component类实例 var renderedComponentInstance = instantiateReactComponent(renderedElement); this._renderedComponent = renderedComponentInstance; //存起来留作后用 //拿到渲染之后的字符串内容，将当前的_rootNodeID传给render出的节点 var renderedMarkup = renderedComponentInstance.mountComponent(this._rootNodeID); //之前我们在React.render方法最后触发了mountReady事件，所以这里可以监听，在渲染完成后会触发。 $(document).on('mountReady', function() &#123; //调用inst.componentDidMount inst.componentDidMount &amp;&amp; inst.componentDidMount(); &#125;); return renderedMarkup;&#125; 2、更新机制一般在reactjs中我们需要更新时都是调用的setState1234567//setStateReactClass.prototype.setState = function(newState) &#123; //还记得我们在ReactCompositeComponent里面mount的时候 做了赋值 //所以这里可以拿到 对应的ReactCompositeComponent的实例_reactInternalInstance this._reactInternalInstance.receiveComponent(null, newState);&#125; setState主要调用了对应的component的receiveComponent来实现更新。所有的挂载，更新都应该交给对应的component来管理 就像所有的component都实现了mountComponent来处理第一次渲染，所有的componet类都应该实现receiveComponent用来处理自己的更新 自定义元素的receiveComponent1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//更新ReactCompositeComponent.prototype.receiveComponent = function(nextElement, newState) &#123; //如果接受了新的，就使用最新的element this._currentElement = nextElement || this._currentElement var inst = this._instance; //合并state var nextState = $.extend(inst.state, newState); var nextProps = this._currentElement.props; //改写state inst.state = nextState; //如果inst有shouldComponentUpdate并且返回false。说明组件本身判断不要更新，就直接返回。 if (inst.shouldComponentUpdate &amp;&amp; (inst.shouldComponentUpdate(nextProps, nextState) === false)) return; //生命周期管理，如果有componentWillUpdate，就调用，表示开始要更新了。 if (inst.componentWillUpdate) inst.componentWillUpdate(nextProps, nextState); var prevComponentInstance = this._renderedComponent; var prevRenderedElement = prevComponentInstance._currentElement; //重新执行render拿到对应的新element; var nextRenderedElement = this._instance.render(); //判断是需要更新还是直接就重新渲染 //注意这里的_shouldUpdateReactComponent跟上面的不同哦 这个是全局的方法 if (_shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) &#123; //如果需要更新，就继续调用子节点的receiveComponent的方法，传入新的element更新子节点。 prevComponentInstance.receiveComponent(nextRenderedElement); //调用componentDidUpdate表示更新完成了 inst.componentDidUpdate &amp;&amp; inst.componentDidUpdate(); &#125; else &#123; //如果发现完全是不同的两种element，那就干脆重新渲染了 var thisID = this._rootNodeID; //重新new一个对应的component， this._renderedComponent = this._instantiateReactComponent(nextRenderedElement); //重新生成对应的元素内容 var nextMarkup = _renderedComponent.mountComponent(thisID); //替换整个节点 $('[data-reactid="' + this._rootNodeID + '"]').replaceWith(nextMarkup); &#125;&#125;//用来判定两个element需不需要更新//这里的key是我们createElement的时候可以选择性的传入的。用来标识这个element，当发现key不同时，我们就可以直接重新渲染，不需要去更新了。var _shouldUpdateReactComponent ＝ function(prevElement, nextElement)&#123; if (prevElement != null &amp;&amp; nextElement != null) &#123; var prevType = typeof prevElement; var nextType = typeof nextElement; if (prevType === 'string' || prevType === 'number') &#123; return nextType === 'string' || nextType === 'number'; &#125; else &#123; return nextType === 'object' &amp;&amp; prevElement.type === nextElement.type &amp;&amp; prevElement.key === nextElement.key; &#125; &#125; return false;&#125; inst.shouldComponentUpdate是实例方法，当我们不希望某次setState后更新，我们就可以重写这个方法，返回false就好了。 _shouldUpdateReactComponent是一个全局方法，这个是一种reactjs的优化机制。用来决定是直接全部替换，还是使用很细微的改动。当两次render出来的子节点key不同，直接全部重新渲染一遍，替换就好了。否则，我们就得来个递归的更新，保证最小化的更新机制，这样可以不会有太大的闪烁。 首先合并改动，生成最新的state,props然后拿以前的render返回的element跟现在最新调用render生成的element进行对比（_shouldUpdateReactComponent），看看需不需要更新，如果要更新就继续调用对应的component类对应的receiveComponent就好啦，其实就是直接当甩手掌柜，事情直接丢给手下去办了。当然还有种情况是，两次生成的element差别太大，就不是一个类型的，那就直接重新生成一份新的代码重新渲染一次。 自定义元素的更新，主要是更新render出的节点，做甩手掌柜交给render出的节点的对应component去管理更新。 text节点的更新很简单，直接更新文案。 浏览器基本元素的更新，分为两块：1.先是更新属性，对比出前后属性的不同，局部更新。并且处理特殊属性，比如事件绑定。2.更新子节点，子节点更新主要是找出差异对象，找差异对象的时候使用_shouldUpdateReactComponent来判断，如果是可以直接更新的就会递归调用子节点的更新，这样也会递归查找差异对象。 更新属性1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071ReactDOMComponent.prototype._updateDOMProperties = function(lastProps, nextProps) &#123; var propKey; //遍历，当一个老的属性不在新的属性集合里时，需要删除掉。 for (propKey in lastProps) &#123; //新的属性里有，或者propKey是在原型上的直接跳过。这样剩下的都是不在新属性集合里的。需要删除 if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey)) &#123; continue; &#125; //对于那种特殊的，比如这里的事件监听的属性我们需要去掉监听 if (/^on[A-Za-z]/.test(propKey)) &#123; var eventType = propKey.replace('on', ''); //针对当前的节点取消事件代理 $(document).undelegate('[data-reactid="' + this._rootNodeID + '"]', eventType, lastProps[propKey]); continue; &#125; //从dom上删除不需要的属性 $('[data-reactid="' + this._rootNodeID + '"]').removeAttr(propKey) &#125; //对于新的属性，需要写到dom节点上 for (propKey in nextProps) &#123; //对于事件监听的属性我们需要特殊处理 if (/^on[A-Za-z]/.test(propKey)) &#123; var eventType = propKey.replace('on', ''); //以前如果已经有，说明有了监听，需要先去掉 lastProps[propKey] &amp;&amp; $(document).undelegate('[data-reactid="' + this._rootNodeID + '"]', eventType, lastProps[propKey]); //针对当前的节点添加事件代理,以_rootNodeID为命名空间 $(document).delegate('[data-reactid="' + this._rootNodeID + '"]', eventType + '.' + this._rootNodeID, nextProps[propKey]); continue; &#125; if (propKey == 'children') continue; //添加新的属性，或者是更新老的同名属性 $('[data-reactid="' + this._rootNodeID + '"]').prop(propKey, nextProps[propKey]) &#125;&#125;``` #### 更新子节点更新子节点包含两个部分，一个是递归的分析差异，把差异添加到队列中。然后在合适的时机调用_patch把差异应用到dom上```jsReactDOMComponent.prototype.receiveComponent = function(nextElement)&#123; var lastProps = this._currentElement.props; var nextProps = nextElement.props; this._currentElement = nextElement; //需要单独的更新属性 this._updateDOMProperties(lastProps,nextProps); //再更新子节点 this._updateDOMChildren(nextProps.children);&#125;//全局的更新深度标识var updateDepth = 0;//全局的更新队列，所有的差异都存在这里var diffQueue = [];ReactDOMComponent.prototype._updateDOMChildren = function(nextChildrenElements)&#123; updateDepth++ //_diff用来递归找出差别,组装差异对象,添加到更新队列diffQueue。 this._diff(diffQueue,nextChildrenElements); updateDepth-- if(updateDepth == 0)&#123; //在需要的时候调用patch，执行具体的dom操作 this._patch(diffQueue); diffQueue = []; &#125;&#125; _diff用来递归找出差别,组装差异对象,添加到更新队列diffQueue。 _patch主要就是挨个遍历差异队列，遍历两次，第一次删除掉所有需要变动的节点，然后第二次插入新的节点还有修改的节点。这里为什么可以直接挨个的插入呢？原因就是我们在diff阶段添加差异节点到差异队列时，本身就是有序的，也就是说对于新增节点（包括move和insert的）在队列里的顺序就是最终dom的顺序，所以我们才可以挨个的直接根据index去塞入节点。 _diff实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140//差异更新的几种类型var UPATE_TYPES = &#123; MOVE_EXISTING: 1, REMOVE_NODE: 2, INSERT_MARKUP: 3&#125;//普通的children是一个数组，此方法把它转换成一个map,key就是element的key,如果是text节点或者element创建时并没有传入key,就直接用在数组里的index标识function flattenChildren(componentChildren) &#123; var child; var name; var childrenMap = &#123;&#125;; for (var i = 0; i &lt; componentChildren.length; i++) &#123; child = componentChildren[i]; name = child &amp;&amp; child._currentelement &amp;&amp; child._currentelement.key ? child._currentelement.key : i.toString(36); childrenMap[name] = child; &#125; return childrenMap;&#125;//主要用来生成子节点elements的component集合//这边注意，有个判断逻辑，如果发现是更新，就会继续使用以前的componentInstance,调用对应的receiveComponent。//如果是新的节点，就会重新生成一个新的componentInstance，function generateComponentChildren(prevChildren, nextChildrenElements) &#123; var nextChildren = &#123;&#125;; nextChildrenElements = nextChildrenElements || []; $.each(nextChildrenElements, function(index, element) &#123; var name = element.key ? element.key : index; var prevChild = prevChildren &amp;&amp; prevChildren[name]; var prevElement = prevChild &amp;&amp; prevChild._currentElement; var nextElement = element; //调用_shouldUpdateReactComponent判断是否是更新 if (_shouldUpdateReactComponent(prevElement, nextElement)) &#123; //更新的话直接递归调用子节点的receiveComponent就好了 prevChild.receiveComponent(nextElement); //然后继续使用老的component nextChildren[name] = prevChild; &#125; else &#123; //对于没有老的，那就重新新增一个，重新生成一个component var nextChildInstance = instantiateReactComponent(nextElement, null); //使用新的component nextChildren[name] = nextChildInstance; &#125; &#125;) return nextChildren;&#125;//_diff用来递归找出差别,组装差异对象,添加到更新队列diffQueue。ReactDOMComponent.prototype._diff = function(diffQueue, nextChildrenElements) &#123; var self = this; //拿到之前的子节点的 component类型对象的集合,这个是在刚开始渲染时赋值的 //_renderedChildren 本来是数组，我们搞成map var prevChildren = flattenChildren(self._renderedChildren); //生成新的子节点的component对象集合，这里注意，会复用老的component对象 var nextChildren = generateComponentChildren(prevChildren, nextChildrenElements); //重新赋值_renderedChildren，使用最新的。 self._renderedChildren = [] $.each(nextChildren, function(key, instance) &#123; self._renderedChildren.push(instance); &#125;) var nextIndex = 0; //代表到达的新的节点的index //通过对比两个集合的差异，组装差异节点添加到队列中 for (name in nextChildren) &#123; if (!nextChildren.hasOwnProperty(name)) &#123; continue; &#125; var prevChild = prevChildren &amp;&amp; prevChildren[name]; var nextChild = nextChildren[name]; //相同的话，说明是使用的同一个component,所以我们需要做移动的操作 if (prevChild === nextChild) &#123; //添加差异对象，类型：MOVE_EXISTING diffQueue.push(&#123; parentId: self._rootNodeID, parentNode: $('[data-reactid=' + self._rootNodeID + ']'), type: UPATE_TYPES.MOVE_EXISTING, fromIndex: prevChild._mountIndex, toIndex: nextIndex &#125;) &#125; else &#123; //如果不相同，说明是新增加的节点 //但是如果老的还存在，就是element不同，但是component一样。我们需要把它对应的老的element删除。 if (prevChild) &#123; //添加差异对象，类型：REMOVE_NODE diffQueue.push(&#123; parentId: self._rootNodeID, parentNode: $('[data-reactid=' + self._rootNodeID + ']'), type: UPATE_TYPES.REMOVE_NODE, fromIndex: prevChild._mountIndex, toIndex: null &#125;) //如果以前已经渲染过了，记得先去掉以前所有的事件监听，通过命名空间全部清空 if (prevChild._rootNodeID) &#123; $(document).undelegate('.' + prevChild._rootNodeID); &#125; &#125; //新增加的节点，也组装差异对象放到队列里 //添加差异对象，类型：INSERT_MARKUP diffQueue.push(&#123; parentId: self._rootNodeID, parentNode: $('[data-reactid=' + self._rootNodeID + ']'), type: UPATE_TYPES.INSERT_MARKUP, fromIndex: null, toIndex: nextIndex, markup: nextChild.mountComponent() //新增的节点，多一个此属性，表示新节点的dom内容 &#125;) &#125; //更新mount的index nextChild._mountIndex = nextIndex; nextIndex++; &#125; //对于老的节点里有，新的节点里没有的那些，也全都删除掉 for (name in prevChildren) &#123; if (prevChildren.hasOwnProperty(name) &amp;&amp; !(nextChildren &amp;&amp; nextChildren.hasOwnProperty(name))) &#123; //添加差异对象，类型：REMOVE_NODE diffQueue.push(&#123; parentId: self._rootNodeID, parentNode: $('[data-reactid=' + self._rootNodeID + ']'), type: UPATE_TYPES.REMOVE_NODE, fromIndex: prevChild._mountIndex, toIndex: null &#125;) //如果以前已经渲染过了，记得先去掉以前所有的事件监听 if (prevChildren[name]._rootNodeID) &#123; $(document).undelegate('.' + prevChildren[name]._rootNodeID); &#125; &#125; &#125;&#125; __patch的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//用于将childNode插入到指定位置function insertChildAt(parentNode, childNode, index) &#123; var beforeChild = parentNode.children().get(index); beforeChild ? childNode.insertBefore(beforeChild) : childNode.appendTo(parentNode);&#125;ReactDOMComponent.prototype._patch = function(updates) &#123; var update; var initialChildren = &#123;&#125;; var deleteChildren = []; for (var i = 0; i &lt; updates.length; i++) &#123; update = updates[i]; if (update.type === UPATE_TYPES.MOVE_EXISTING || update.type === UPATE_TYPES.REMOVE_NODE) &#123; var updatedIndex = update.fromIndex; var updatedChild = $(update.parentNode.children().get(updatedIndex)); var parentID = update.parentID; //所有需要更新的节点都保存下来，方便后面使用 initialChildren[parentID] = initialChildren[parentID] || []; //使用parentID作为简易命名空间 initialChildren[parentID][updatedIndex] = updatedChild; //所有需要修改的节点先删除,对于move的，后面再重新插入到正确的位置即可 deleteChildren.push(updatedChild) &#125; &#125; //删除所有需要先删除的 $.each(deleteChildren, function(index, child) &#123; $(child).remove(); &#125;) //再遍历一次，这次处理新增的节点，还有修改的节点这里也要重新插入 for (var k = 0; k &lt; updates.length; k++) &#123; update = updates[k]; switch (update.type) &#123; case UPATE_TYPES.INSERT_MARKUP: insertChildAt(update.parentNode, $(update.markup), update.toIndex); break; case UPATE_TYPES.MOVE_EXISTING: insertChildAt(update.parentNode, initialChildren[update.parentID][update.fromIndex], update.toIndex); break; case UPATE_TYPES.REMOVE_NODE: // 什么都不需要做，因为上面已经帮忙删除掉了 break; &#125; &#125;&#125; 差异更新类型 MOVE_EXISTING: 新的component类型在老的集合里也有，并且element是可以更新的类型，在generateComponentChildren我们已经调用了receiveComponent，这种情况下prevChild=nextChild,那我们就需要做出移动的操作，可以复用以前的dom节点。 INSERT_MARKUP: 新的component类型不在老的集合里，那么就是全新的节点，我们需要插入新的节点 REMOVE_NODE: 老的component类型，在新的集合里也有，但是对应的element不同了不能直接复用直接更新，那我们也得删除。 REMOVE_NODE: 老的component不在新的集合里的，我们需要删除。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>-React -ES6</tag>
      </tags>
  </entry>
</search>
